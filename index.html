<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="utils.js"></script>
    <script src="https://code.jquery.com/jquery-2.2.4.js"
            integrity="sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI="
            crossorigin="anonymous"></script>

    <script src="three.js"></script>

    <script src="STLLoader.js"></script>

    <script src="axis.js"></script>

    <script>
        var world = {
            scene: null,
            lights: [],
            camera: null,
            renderer: null,
            raycaster: null,
            mouse: null,
            rotate: false
        };
        var Yaw_Servo = null;
        var Roll_Servo = null;
        var irSensor = null;
        var reference = null; //reference point of scanner distance
        var scanLine = null;
        var testObject = null; //object to scan

        var theta = 0;
        var phi = 0;


        function buildCamera(scene) {
            var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.radius = 25;
            camera.theta = d2r(22.5);
            camera.phi = d2r(22.5);
            camera.scene = scene;

            camera.update = function () {
                var theta = this.theta;
                var phi = this.phi;
                var radius = this.radius;

                this.position.x = radius * Math.sin(theta) * Math.cos(phi);
                this.position.y = radius * Math.sin(phi);
                this.position.z = radius * Math.cos(theta) * Math.cos(phi);

                this.updateMatrix();
                this.lookAt(this.scene.position);
                this.updateMatrixWorld();
            };


            // camera control events
            $(document).mousedown(function (event) {
                camera.mouse = mouse2vec(event);
                camera.rotate = (event.buttons & 4); //middle button

                /*var r = new THREE.Raycaster();
                r.setFromCamera(camera.mouse, world.camera);
                var intersect = r.intersectObject(Yaw_Servo);
                if(intersect.length > 0){

                }
                console.log(intersect);
                console.log(intersect[0].point);
                */
            });


            // rotate
            $(document).mousemove(function (event) {
                event.preventDefault();
                var mouse = mouse2vec(event);

                if (camera.rotate) {
                    var delta = mouse.clone().sub(camera.mouse);
                    camera.theta -= delta.x;
                    camera.phi -= delta.y;
                    camera.update();
                }

                camera.mouse = mouse;
            });

            // end rotation
            $(document).mouseup(function (event) {
                camera.rotate = false;
            });

            // dolly ("zoom")
            $(document).get(0).addEventListener('mousewheel', function (e) {
                camera.radius *= ((e.wheelDelta < 0) ? 1.05 : 0.95);
                camera.update();
            });

            return camera;
        }


        function addIR(callback) {
            var loader = new THREE.STLLoader();
            loader.load('IR.STL', function (g) {
                var m = new THREE.MeshPhongMaterial({
                    color: 0xA05522,
                    shading: THREE.SmoothShading,
                    specular: 0xffffff,
                    emissive: 0xFF0000,
                    shininess: 30,
                    overdraw: true
                });
                //var m = new THREE.MeshLambertMaterial({color: 0xAA5522});
                var mesh = new THREE.Mesh(g, m);
                callback(mesh);
            });
        }

        function addYawServo(callback) {
            var loader = new THREE.STLLoader();
            loader.load('Servo.STL', function (g) {
                var m = new THREE.MeshPhongMaterial({
                    color: 0xA05522,
                    shading: THREE.SmoothShading,
                    specular: 0xffffff,
                    emissive: 0x0000FF,
                    shininess: 30,
                    overdraw: true
                });
                var mesh = new THREE.Mesh(g, m);
                callback(mesh);
            });
        }

        function addRollServo(callback) {
            var loader = new THREE.STLLoader();
            loader.load('Servo.STL', function (g) {
                var m = new THREE.MeshPhongMaterial({
                    color: 0xA05522,
                    shading: THREE.SmoothShading,
                    specular: 0xffffff,
                    emissive: 0x00FF00,
                    shininess: 30,
                    overdraw: true
                });
                var mesh = new THREE.Mesh(g, m);
                callback(mesh);
            });
        }

        function addPointer(x, y, z) {
            var pointer = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshBasicMaterial({color: 0xFF0000}));
            pointer.position.set(x, y, z);
            world.scene.add(pointer);
        }

        function allLoaded() {
            if (irSensor != null && Yaw_Servo != null && Roll_Servo != null) {
                console.log("ALL LOADED !!!");

                Yaw_Servo.rotation.set(d2r(-90), 0, 0);
                Yaw_Servo.wrapper = new THREE.Object3D(); //"pan" servo
                Yaw_Servo.wrapper.add(Yaw_Servo);

                Roll_Servo.position.set(0.0, 0, -1.6 / 2);
                Roll_Servo.wrapper = new THREE.Object3D();
                Roll_Servo.wrapper.position.set(0.5, 1.6 + (0.78 / 2) + (0.5), 0);
                Roll_Servo.wrapper.add(Roll_Servo);


                irSensor.rotation.set(0.0, d2r(90), 0.0);
                irSensor.position.set(1.5, 0.0, 0.0);
                irSensor.wrapper = new THREE.Object3D();
                irSensor.wrapper.add(irSensor);

                reference = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshBasicMaterial({color: 0x000000}));
                reference.position.set(1.0, 0.0, 0.0);
                irSensor.add(reference);

                Roll_Servo.wrapper.add(irSensor.wrapper);

                Yaw_Servo.wrapper.add(Roll_Servo.wrapper);

                //world.scene.add(irSensor);
                //world.scene.add(Roll_Servo);
                world.scene.add(Yaw_Servo.wrapper);

                //start
                animate();
            }
        }

        $(document).ready(function () {

            world.scene = new THREE.Scene();

            // lights
            world.scene.add(new THREE.AmbientLight(0xeeeeee, 0.1));

            var light = new THREE.DirectionalLight(0xffffff, 0.3);
            light.position.set(1, 1, 1).normalize();
            world.scene.add(light);

            //addPointer(0,10,-10);

            light = new THREE.PointLight(0xffffff, 0.7, 100);
            light.position.set(0, 10, -10);
            world.scene.add(light);

            // axes
            var origin = new THREE.Vector3(0, 0, 0);
            var axes = buildAxes(origin, 100);
            world.scene.add(axes);

            // camera
            world.camera = buildCamera(world.scene);
            world.camera.update();

            // renderer
            world.renderer = new THREE.WebGLRenderer();
            world.renderer.setClearColor(0xf0f0f0);
            world.renderer.setPixelRatio(window.devicePixelRatio);
            world.renderer.setSize(window.innerWidth, window.innerHeight);
            world.renderer.sortObjects = false;

            $("#container").append(world.renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);

            addIR(function (mesh) {
                irSensor = mesh;
                //mesh.position.set(5,5,5);
                //world.scene.add(mesh);
                allLoaded();
            });

            addYawServo(function (mesh) {
                Yaw_Servo = mesh;
                //mesh.position.set(5,0,0);
                //world.scene.add(mesh);
                allLoaded();
            });

            addRollServo(function (mesh) {
                Roll_Servo = mesh;
                //mesh.position.set(0,0,5);
                //world.scene.add(mesh);
                allLoaded();
            });


            var geom = new THREE.Geometry();
            geom.vertices.push(new THREE.Vector3(0,0,0));
            geom.vertices.push(new THREE.Vector3(0,0,0));
            var mat = new THREE.LineDashedMaterial({linewidth: 3, color: 0xFF00FF, dashSize: 0.1, gapSize: 0.1});
            scanLine = new THREE.Line(geom, mat, THREE.LineSegments);
            world.scene.add(scanLine);

            testObject = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.0, 3.0), new THREE.MeshBasicMaterial({color: 0x00FFFF}));
            testObject.position.set(8.0,0.0,4.0);

            world.scene.add(testObject);

            $(document).keydown(function(event){
                switch(event.key){
                    case "ArrowLeft":
                        event.preventDefault();
                        theta += d2r(2);
                        break;
                    case "ArrowRight":
                        event.preventDefault();
                        theta -= d2r(2);
                        break;
                    case "ArrowDown":
                        event.preventDefault();
                        phi -= d2r(2);
                        break;
                    case "ArrowUp":
                        event.preventDefault();
                        phi += d2r(2);
                        break;
                }
            })

        });
        function addScanPoint(delta,theta,phi){
            var v = new THREE.Vector3(0,0,delta); // point in IR's coordinate system, positive z direction

            //reference
            var mat = new THREE.Matrix4();
            mat.makeTranslation(1.0,0,0); // reference offset from IR Sensor
            v.applyMatrix4(mat);

            //irSensor
            mat.makeRotationY(d2r(90)); // (reorienting CAD (probably unnecessary in real model)
            v.applyMatrix4(mat);
            mat.makeTranslation(1.5,0,0); //IR Sensor offset from Roll Pivot
            v.applyMatrix4(mat);

            //ir Wrapper
            mat.makeRotationZ(phi); // Roll Angle
            v.applyMatrix4(mat);

            //Roll Servo
            mat.makeRotationY(theta); // Yaw Angle
            v.applyMatrix4(mat);

            mat.makeTranslation(0.5, 1.6 + (0.78 / 2) + (0.5), 0); // Roll Pivot offset from Yaw Pivot
            v.applyMatrix4(mat); //this part is actually unnecessary unless we're doing localization, in which global coordinates really matter

            //equivalently,
            /*
            v.applyMatrix4(reference.matrix);
            v.applyMatrix4(irSensor.matrix);
            v.applyMatrix4(irSensor.wrapper.matrix);
            v.applyMatrix4(Roll_Servo.wrapper.matrix);
            v.applyMatrix4(Yaw_Servo.wrapper.matrix);
            */

            addPointer(v.x, v.y, v.z);
        }

        function mouse2vec(event) {
            return new THREE.Vector3(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1,
                    0.0
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function scan() {

            var pos = new THREE.Vector3();
            pos.setFromMatrixPosition(reference.matrixWorld);

            var direction = new THREE.Vector3(
                    Math.cos(phi) * Math.cos(-theta),
                    Math.sin(phi),
                    Math.cos(phi) * Math.sin(-theta)
            );

            var src = pos.clone();
            var dst = src.clone().add(direction.clone().multiplyScalar(10));

            // show scan Line
            scanLine.geometry.vertices[0].copy(src);
            scanLine.geometry.vertices[1].copy(dst);
            scanLine.geometry.computeLineDistances();
            scanLine.geometry.verticesNeedUpdate = true;

            // add Scan Data

            var r = new THREE.Raycaster(src,direction,0,20);

            var intersect = r.intersectObject(testObject);

            if(intersect.length > 0){
                var v_delta = new THREE.Vector3();
                v_delta.subVectors(src, intersect[0].point);
                var delta = v_delta.length();
                // artificially create delta [distance] (obtained via IR sensor reading in real life)

                addScanPoint(delta, theta, phi);
            }
        }

        function render() {
            Roll_Servo.wrapper.rotation.set(0, theta, 0);
            irSensor.wrapper.rotation.set(0, 0, phi);
            scan();
            world.renderer.render(world.scene, world.camera);
        }

        function onWindowResize() {
            world.camera.aspect = window.innerWidth / window.innerHeight;
            world.camera.updateProjectionMatrix();
            world.renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</head>

<body>

<div id="container">
    <!-- Scanner{IR Sensor-Servo} & Object-->
</div>

<div id="ui-container">

</div>

</body>
</html>